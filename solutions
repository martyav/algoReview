//: Playground - noun: a place where people can play

import UIKit

/*
 Examples of different kinds of runtime
 */

// linear time below

func printAllArrItems(_ arr:[Int]) {
    for item in arr {
        print(item)
    }
}

// constant time below

func printOneArrItem(_ arr:[Int], index: Int) {
    print(arr[index])
}

// quadratic time below

func printDeck(suits: [Character], nums: [String]) {
    for suit in suits {
        for num in nums {
            print("The \(num) of \(suit)s.")
        }
    }
}

// cubic time below

func printPokemonDeets(names: [String], nums: [Int], regions: [String]) {
    for region in regions {
        for num in nums {
            for name in names {
                print(region, num, name)
            }
        }
    }
}

// linearithmic?

func orderPokemonByName(box: [String]) {
    let sortedPokemon = box.sorted(by: <)
    print(sortedPokemon)
}

/* 
 Next problem...diagonal difference!
 */

func calcDiag(_ matrix: [[Int]]) -> Int {
    var diff = 0
    var sumLeftToRight = 0
    var sumRightToLeft = 0

    for index in 0..<matrix.count {
        sumLeftToRight += matrix[index][index]
        sumRightToLeft += matrix[index][(matrix.count - 1) - index]
    }

    diff = sumRightToLeft - sumLeftToRight

    if diff >= 0 {
        return diff
    } else {
        return diff * -1
    }
}

var arr = [[1,2,3,4], [5,6,7,9], [10,11,12,13], [14,15,16,17]]

print(calcDiag(arr))

/*
 Does a number in an array have the same number on the left as on the right?
 */

func surroundedByEquals(_ arr: [Int]) -> Int? {
    var foundIndex: Int?

    for index in 1..<arr.count - 1 {
        if arr[index - 1] == arr[index + 1] {
            foundIndex = index
            continue
        }
    }
    return foundIndex
}

surroundedByEquals([3,1,3])


//Extend an array to implement your own filter() method. Bonus: extend an array to implement your own reduce() method.

extension Array {
    func myFilter<T>(_ closure: (T) -> Bool) -> [T] {
        var newArr = [T]()

        for item in self {
            let castAsT = item as! T
            if closure(castAsT) {
                newArr.append(castAsT)
            }
        }
        
        return newArr
    }

//    func myReduce<T>(_ closure: (T,T) -> T) -> T {
//        var total: T
//
//        for item in self {
//            let castAsT = item as! T
//            
//        }
//    }
}

var input1 = [1,3,6,7]
var input2 = [2,4,5,9,10]
//Sample output: [1,2,3,4,5,6,7,9,10]

//Given two sorted arrays, write a function that returns a single sorted array with all of the elements of the two input arrays. Your solution should work in O(n) time.

func joinUp(_ arr1: [Int], _ arr2: [Int]) -> [Int] {
    var finalArr = [Int]()
    var temp: Int = 0
    var tempMergedArr = [Int]()

    for el in arr1 {
        tempMergedArr.append(el)
    }
    for el in arr2 {
        tempMergedArr.append(el)
    }

    for indexOfElement1 in 0..<tempMergedArr.count {
        if indexOfElement1 == 0 {
            finalArr.append(tempMergedArr[0])
            temp = finalArr[indexOfElement1]
        } else {
            if tempMergedArr[indexOfElement1] > temp {
                finalArr.append(tempMergedArr[indexOfElement1])
            } else {
                finalArr.append(temp)
                temp = finalArr[indexOfElement1]
            }
        }
    }

    return finalArr
}

print(joinUp(input1, input2))

/*
 struct user {
 var name: String
 var userID: Int
 }
 
 www.questionOne.com/userName=Dave&userID=31&userFound=true
 
 www.questionOne.com/userName=Aliya&userID=319&userFound=true
 
 www.questionOne.com/userName=Jonathan&userID=4829&userFound=true
 */

struct User {
    var name: String
    var userID: Int

    let theStartOfOurBaseURL: String = "www.questionOne.com/userName"
    let theMiddleOfOurBaseURL: String = "&userID="
    let theEndOfOurBaseURL: String = "&userFound=true"

    init(name: String, userID: Int) {
        self.name = name
        self.userID = userID
    }

    func displayProfile() -> URL {
        return URL(fileURLWithPath: theStartOfOurBaseURL + name + theMiddleOfOurBaseURL + String(userID) + theEndOfOurBaseURL)
    }
}

func constructUser(userURL: String) -> User {
    let decomposedURL = userURL.components(separatedBy: "=")

    let name = decomposedURL[1].components(separatedBy: "&")[0]
    let userID = decomposedURL[2].components(separatedBy: "&")[0]

    return User(name: name, userID: Int(userID)!)
}

var Jon = constructUser(userURL:"www.questionOne.com/userName=Jonathan&userID=4829&userFound=true")
print("")
print(Jon.displayProfile())
print("")

var decomposed = "www.questionOne.com/userName=Dave&userID=31&userFound=true".components(separatedBy: "=")
print(decomposed)
let name = decomposed[1].components(separatedBy: "&")[0]
let userID = decomposed[2].components(separatedBy: "&")[0]

let input = [5,3,4,-2,-7]
let output = (2, -105, -9)

//Given an array of Ints as input, write a function that returns a Tuple, where the first value is the sum of the even numbers, the second value is the product of the odd numbers, and the third number is the sum of the negative numbers. *

func processArr(_ arr: [Int]) -> (Int, Int, Int) {
    var sumOfEvens = 0
    var productOfOdds = 1
    var sumOfNegs = 0

    for num in arr {
        if num < 0 {
            sumOfNegs += num
        }

        if num % 2 == 0 {
            sumOfEvens += num
        } else {
            productOfOdds *= num
        }
    }

    return (sumOfEvens,productOfOdds,sumOfNegs)
}

print(processArr(input))
print(output)

/*
 Given nums = [2, 11, 7, 15],  target = 9
 Sample Output: (0, 2)
 
 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution.
 */

let nums = [2, 11, 7, 15]
let target = 9

func findTheTargetSum(_ arr: [Int], target: Int) -> (Int?,Int?) {
    var addend1:Int?
    var addend2: Int?

    for indexOfNum1 in 0..<arr.count {
        for indexOfNum2 in 0..<arr.count {
            if arr[indexOfNum1] + arr[indexOfNum2] == target {
                addend1 = indexOfNum1
                addend2 = indexOfNum2
            }
        }
    }

    return (addend1, addend2)
}

findTheTargetSum(nums, target: 9)

func findTheTargetSumAlternate(_ arr: [Int], target: Int) -> (Int?,Int?) {
    var addend1:Int?
    var addend2: Int?
    var diff: Int
    var checkerArr = [Int]()

    for indexOfNum1 in 0..<arr.count {
        if target > arr[indexOfNum1] {
            diff = target - arr[indexOfNum1]
        } else {
            diff = arr[indexOfNum1] - target
        }
        checkerArr.append(diff)
    }

    for findingTheMatch in 0..<arr.count {
        var counter = 0
        if arr[findingTheMatch + counter] + checkerArr[(arr.count - 1) - findingTheMatch] == target {
            print(checkerArr[(arr.count - 1) - findingTheMatch])
            addend1 = findingTheMatch + counter
            addend2 = (arr.count - 1) - findingTheMatch
            break
        } else {
            counter += 1
            continue
        }
    }

    return (addend1, addend2)
}

findTheTargetSumAlternate(nums, target: 18)

struct Person {
    var clothes: String {
        willSet {
            updateUI(msg: "I'm changing from \(clothes) to \(newValue)")
        }

        didSet {
            updateUI(msg: "I just changed from \(oldValue) to \(clothes)")
        }
    }
}

func updateUI(msg: String) {
    print(msg)
}

var taylor = Person(clothes: "T-shirts")
taylor.clothes = "short skirts"


//Given an array of integers, return all the positive numbers that have their opposites in the array.

let barr: [Int] = [1,2,5,-5,0,-6,-5,9,10,-1,4,5,0,5,5,-1,1]

func findOpposite(_ arr: [Int]) -> [Int] {
    var ourOpposites:[Int] = []

    guard arr.count > 1 else { return ourOpposites }

    for checkMe in arr where checkMe > 0 {
        for checkAgainst in arr where checkAgainst < 0{
            if checkMe * -1 == checkAgainst {
                guard !ourOpposites.contains(checkMe) else { break }
                ourOpposites.append(checkMe)
            }
        }
    }

    return ourOpposites
}

findOpposite(barr)

// Chris's code -- linear time (https://github.com/cristopherchavezny)

func numWhosOppositeIsInThe(arr: [Int]) -> Set<Int> {
    var answer = Set<Int>()
    for num in arr {
        if arr.contains(-num), num > 0, !answer.contains(num) {
            answer.insert(num)
        }
    }
    return answer
}

numWhosOppositeIsInThe(arr: barr)

func noDuplicates(_ arr: [Int]) -> [Int] {
    var container = [Int]()
    for item in arr {
        guard !container.contains(item) else {continue}
        container.append(item)
    }
    
    return container
}

var winput = [4,3,3,2,3,2,5,4,4]
var woutput = [4,3,2,5]

noDuplicates(winput)

//return only the elements shared by two arrays

func sharedElements(arr1: [Int], arr2: [Int]) -> [Int] {
    let set1 = Set(arr1)
    let set2 = Set(arr2)

    return Array(set1.intersection(set2))
}

func sharedElements2(arr1: [Int], arr2: [Int]) -> [Int] {
    var shared = [Int]()

    for index in 0..<arr1.count {
        for jindex in 0..<arr2.count {
            guard arr1[index] == arr2[jindex] else { continue }
            shared.append(arr1[index])
        }
    }

    shared = noDuplicates(shared)

    return shared
}

let carr1 = [1,443,43,4,3,42,3,4,234,1,31,3,12,31,3,12,31,23,9]
let carr2 = [123123,12,31,3,123,12,3,12,3,234,32,41,23,1,4,456,34,4,124,1,4]

print(sharedElements2(arr1: carr1, arr2: carr2))
print(sharedElements(arr1: carr1, arr2: carr2))


func countUp(_ target: Int, startingAt: Int) {
    print(startingAt)
    
    if startingAt == target { return }
    else { return countUp(target, startingAt: startingAt + 1) }
}

var one = 1

countUp(10, startingAt: one)

// find anagrams, ignoring punctuation, cases, and spacing

func findAnagram(one: String, two: String) -> Bool {
    let text1 = one.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines.union(CharacterSet.punctuationCharacters)).lowercased()
    let text2 = two.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines.union(CharacterSet.punctuationCharacters)).lowercased()

    var textArr1 = [Character]()
    var textArr2 = [Character]()

    for letter in text1.characters {
        textArr1.append(letter)
    }

    for letter in text2.characters {
        textArr2.append(letter)
    }

    return textArr2.sorted() == textArr1.sorted()
}
findAnagram(one: "catp", two: "act!")


var darr = [1,3,3,434,34,3,42,3]

func recursivelyPrintElements(in arr: [Int], index: Int = 0) {
    guard index != (arr.count - 1) else { return }
    
    print(arr[index])
    
    return recursivelyPrintElements(in: arr, index: index + 1)
}

/*
Input = "The quick brown fox jumps over the lazy dog."
Output = True

Input = "How vexingly quick daft zebras jump!"

Output = True

Input = "Some other sentence without all the letters."

Output = False

A pangram is a sentence that uses every letter of the alphabet at least once. A famous pangram is "The quick brown fox jumps over the lazy dog." Given a String, return whether or not it is a pangram. Ignore capitalization and punctuation.
*/

func isPangram(_ text: String) -> Bool {
    let alphabet: Set<Character> = Set("abcdefghijklmnopqrstuvwxyz ".characters)
    var cleanText = text.trimmingCharacters(in: CharacterSet.punctuationCharacters).lowercased()
    
    print(cleanText)
    
    let checker: Set<Character> = Set(cleanText.characters)
    
    print(checker.sorted())
    print(alphabet)
    
    return checker == alphabet
}

isPangram("The quick brown fox jumps over the lazy dog.")

/*
 Input = "Racecar"
 Output = True
 
 Input = "Madam"
 
 Output = True
 
 Input = "Apple"
 
 Output = False
 
 Bonus Input: "No lava on Avalon.  No lava?  No avalon."
 
 Bonus Output: True
 
 A palindrome is a word that is the same backwards and forwards. Write a function that determines if a given String is a palindrome. Then write a function that does it recursively. Then do it with a full sentence as input ignoring spaces and punctuation.
 */

func isPalindrome(_ text: String, index: Int = 0) -> Bool {
    let textArr = Array(text.lowercased().characters)
    guard index < textArr.count - 1 - index else { return true }

    if textArr[index] == textArr[(textArr.count - 1) - index] {
        let newIndex = index + 1
        return isPalindrome(text, index: newIndex)
    } else {
        return false
    }
}


var string = "racfwerffrfergweg4wtg4h5gtrbh54h3wb5b4wg35yt53twefqcar"
var gnirts = "racecar"

isPalindrome(string)
isPalindrome(gnirts)

/*
 Input = 412
 Output = 7
 
 Input = 1480
 
 Output = 13
 
 Input = 1023
 
 Output = 6
 
 Given an Int as input, return the sum of its digits. Then do it recursively.
 */

func numerology(_ num: Int) -> Int {
    var sum = 0
    let numArr = Array(String(num).characters)

    for digit in numArr {
        sum += Int(String(digit))!
    }

    return sum
}

numerology(123)

var sum = 0

func recursiveNumerology(_ num: Int) -> Int {
    var numArr = Array(String(num).characters)
    let newNum: Int

    sum += Int(String(describing: numArr[numArr.count - 1]))!
    numArr.removeLast()

    // base case
    guard numArr.count != 0 else { return sum }

    newNum = Int(String(numArr))!
    return recursiveNumerology(newNum)
}

recursiveNumerology(402)

/*
 Input: "Hello, there"
 Output: "HeLlO, tHeRe"
 
 Input: "TESTING"
 
 Output: "TeStInG"
 
 Input: "Here. Have another String as a sample!"
 
 Output: "HeRe. HaVe aNoThEr sTrInG As a sAmPlE!"
 
 Write a function that takes a String as input, and returns a String with every other character capitalized.
 */

func gamzee(_ text: String) -> String {
    var gamzeefied: String = ""

    let textArr = Array(text.uppercased().characters)

    for index in 0..<textArr.count {
        if index % 2 != 0 {
            gamzeefied = gamzeefied + String(textArr[index]).lowercased()
        } else {
            gamzeefied = gamzeefied + String(textArr[index])
        }
    }

    return gamzeefied
}

gamzee("shbcfhjcbjh7werf")

func recursiveGamzee(_ text: String, gamzeefied: String = "", numOfCycles: Int = 0) -> String {
    guard text != "" else { return gamzeefied }

    var internalGamzeefied = gamzeefied
    var textArr = Array(text.characters)
    var internalText = ""

    if numOfCycles % 2 != 0 {
        internalGamzeefied = gamzeefied + String(textArr[0]).lowercased()
    } else {
        internalGamzeefied = gamzeefied + String(textArr[0]).uppercased()
    }

    textArr.removeFirst()
    print(textArr)

    for char in textArr {
        internalText += String(char)
    }

    return recursiveGamzee(internalText, gamzeefied: internalGamzeefied, numOfCycles: numOfCycles + 1)
}

recursiveGamzee("Hello, world!")

class Book {
    var title: String
    var author: String
    init(title: String, author: String) {
        self.title = title
        self.author = author
    }
}

var sampleInput = [ ["title" : "The name of the Wind", "author": "Patrick Rothfuss"] , ["title": "Ubik", "author": "Philip K. Dick"] ]

/*
 Write a function that takes an Array of Dictionaries and a closure as input, and returns Void.  The closure should take an Array of Books as input and return Void.
 
 Your function should convert the Array of Dictionaries into an Array of Books, then call your closure passing in your Array of Books.
 
 After you have completed writing your function, you should call your function passing in sampleInput, and a closure that prints out all of the titles in an Array of Books.
 */

func convertDictionaries(groupOfDictionaries: [[String:String]], printTitles: (_ groupOfBooks: [Book]) -> Void ) -> Void {
    var convertedToBooks: [Book] = []
    
    for item in groupOfDictionaries {
        if let title = item["title"],
            let author = item["author"] {
            let newBook = Book(title: title, author: author)
            convertedToBooks.append(newBook)
        } else { continue }
    }
    
    printTitles(convertedToBooks)
}

let printTitles = { (arrOfBooks: [Book]) in
    for item in arrOfBooks {
        print(item.title)
    }
}

convertDictionaries(groupOfDictionaries: sampleInput, printTitles: printTitles)

/*
 Sample input:
 let arrayOne = ["Amber", "Ana", "Annie", "Cristopher"]
 let arrayTwo = ["Spadafora", "Ma", "Tung", "Chavez"]
 
 class Student {
 let firstName: String
 let lastName: String
 init(first: String, last: String) {
 self.firstName = first
 self.lastName = last
 }
 }
 
 Write a function that takes two Arrays of Strings as input, and returns a dictionary mapping the value at each index of the first Array to the value at each corresponding index of the second Array.  Assume the arrays are both of size n.
 
 Then write a function that takes a dictionary as input and returns an Array of Student objects.
 */


let arrayOne = ["Amber", "Ana", "Annie", "Cristopher"]
let arrayTwo = ["Spadafora", "Ma", "Tung", "Chavez"]

class Student {
    let firstName: String
    let lastName: String
    init(first: String, last: String) {
        self.firstName = first
        self.lastName = last
    }
}

func makeDictFrom(arr1: [String], arr2: [String]) -> [String:String] {
    let n = arr1.count
    var ourDict: [String:String] = [:]

    for index in 0..<n {
        ourDict[arr1[index]] = arr2[index]
    }

    return ourDict
}

var studentArr = makeDictFrom(arr1: arrayOne, arr2: arrayTwo)

func makeStudentFrom(dict: [String:String]) -> [Student] {
    var students = [Student]()

    for (k,v) in dict {
        let firstName = k
        let lastName = v
        let currentstudent = Student(first: firstName, last: lastName)
        students.append(currentstudent)
    }
    return students
}

makeStudentFrom(dict: studentArr)

func anyNumCipher(_ text: String, shiftBy: Int) -> String {
    var enciphered = ""
    let alphabet = Array("abcdefghijklmnopqrstuvwxyz".characters)
    let textArr = Array(text.lowercased().characters)

    for letter in textArr {
        let index = alphabet.index(of: letter)
        if index != nil {
            let newLetter = String(alphabet[(index! + shiftBy) % 26])
            enciphered += newLetter
        } else {
            enciphered += String(letter)
        }
    }

    return enciphered
}

anyNumCipher("abc defg", shiftBy: 3)

//func recursivelyCipher(_ text: String, num: Int, currentPosition: Int = 0) {
//    if text == "" { return }
//
//    let alphabet = Array("abcdefghijklmnopqrstuvwxyz".characters)
//    let textArr = Array(text.lowercased().characters)
//}

/*
 Given an array of n integers where n > 1, return an array of the same size as the input array, where the value at every index of the output array is the product of all elements in the array except the element at the given index.
 
 */
 
let quinput = [10, 4, 1, 6, 2]
let quoutput = [48,120,480,80,240]

func products(arr:[Int]) -> [Int] {
    var newArr: [Int] = []
 
    for index in 0..<arr.count {
        var product = 1
            for jindex in 0..<arr.count where jindex != index {
                product *= arr[jindex]
        }
        newArr.append(product)
    }
 
    return newArr
}
 
let test = products(arr: input)

/*
 You are given an input array, an array of tuples of elements to swap, and a closure mapping two inputs to a Bool.  Make all swaps in order, then return a tuple containing the swapped array and whether or not it is sorted according to the input condition.
 Sample input:
 [1,6,2,9,3], [(1,2), (2,4), (3,4)], {(a, b) -> Bool in return a < b}
 
 Sample output:
 [1,2,3,6,9], true
 */

func makeThisIntoThat(arr: [Int], swaps: [(Int, Int)], closure: ((Int, Int)) -> Bool) -> [Int] {
    var newArr: [Int] = arr
 
    for index in 0..<swaps.count {
        newArr[swaps[index].1] = newArr[swaps[index].0]
    }
 
    return newArr
}


func findDisappearedNumbers(_ nums: [Int]) -> Set<Int> {
    var checkerSet: Set<Int> = []

    for i in 1...nums.count {
        checkerSet.insert(i)
        print(checkerSet)
    }

    for j in nums {
        print(checkerSet.contains(j))
        if checkerSet.contains(j) {
            checkerSet.remove(j)
        }
    }
    return checkerSet
}

findDisappearedNumbers([4,3,2,7,8,2,3,1])

func addDigits(_ num: Int) -> Int {
    var sum = 0
    var numAsString = String(num)
    let numArr = Array(numAsString.characters)
    
    for number in numArr {
        sum += Int(String(number))!
    }
    
    if sum >= 10 {
        return addDigits(sum)
    } else { return sum }
}

addDigits(19)

class Dog {
    var age: Int
    var name: String
    var breed: String
    
    init (age: Int, name: String, breed: String) {
        self.age = age
        self.name = name
        self.breed = breed
    }
}

let dogOne = Dog(age: 4, name: "Scooby", breed: "Great Dane")
let dogTwo = Dog(age: 1, name: "Scrappy", breed: "Great Dane")
let dogThree = Dog(age: 6, name: "Snoopy", breed: "Beagle")
let dogFour = Dog(age: 5, name: "Odie", breed: "Beagle")
let dogFive = Dog(age: 3, name: "Poochie", breed: "Beagle")

let earr = [dogOne, dogTwo, dogThree, dogFour, dogFive]

func findOneExample(arr: [Dog]) -> [String] {
    var uniques: [String] = []

    var listOfBreedsSoFar: [String] = []

    for dog in arr {
        if listOfBreedsSoFar.contains(dog.breed) {
                continue
        } else {
            uniques.append(dog.name)
            listOfBreedsSoFar.append(dog.breed)
        }
    }

    return uniques
}

print(findOneExample(arr: earr))

class Node<T> {
    var key: T!
    var next: Node?
}

class LinkedList<T: Equatable> {
    var head  = Node<T>()
}

func sameHeadAndTail<T: Equatable>(list: LinkedList<T>) -> Bool {
    let checkMe = list.head
    var current = checkMe

    guard checkMe.next != nil else { return true }

    while current.next != nil {
        current = current.next!
    }

    return checkMe.key == current.key
}

var myList2 = LinkedList<String>()
myList2.head.key = "3"
myList2.head.next = Node()
myList2.head.next?.key = "20"
myList2.head.next?.next = Node()
myList2.head.next?.next?.key = "3"

sameHeadAndTail(list: myList2)

func mergeSort(arr: [Int]) -> [Int] {
    guard arr.count > 1 else { return arr }

    let midIndex = arr.count/2

    let left = mergeSort(arr: Array(arr[0..<midIndex]))
    let right = mergeSort(arr: Array(arr[midIndex..<arr.count]))

    return merge(leftArr: left, rightArr: right)
}

func merge(leftArr: [Int], rightArr: [Int]) -> [Int] {
    var leftPointer = 0
    var rightPointer = 0
    var mergedArr = [Int]()

    while leftPointer < leftArr.count && rightPointer < rightArr.count {
        if leftArr[leftPointer] < rightArr[rightPointer] {
            mergedArr.append(leftArr[leftPointer])
            leftPointer += 1
        } else {
            mergedArr.append(rightArr[rightPointer])
            rightPointer += 1
        }
    }

    return mergedArr + leftArr[leftPointer..<leftArr.count] + rightArr[rightPointer..<rightArr.count]
}

let arr1 = [12322322,6,945, 3232,434,32,1221,432423,666]
let arr2 = [2,3,4,7,8]

merge(leftArr: arr1, rightArr: arr2)

func quickSort(arr: [Int]) -> [Int] {
    guard arr.count > 1 else { return arr }

    let pivot = arr[arr.count/2]

    let less = arr.filter{$0 < pivot}
    let equal = arr.filter{$0 == pivot}
    let more = arr.filter{$0 > pivot}

    return quickSort(arr: less) + equal + quickSort(arr: more)
}

quickSort(arr: arr1)

/*
 Write a function that takes two arrays as input, and returns a single array that alternates the elements of each input array.
 Sample  input: [1,4,8,2], [3,9,10,0]
 Sample output: [1,3,4,9,8,10,2,0]
 
 What is the Big O runtime of your algorithm?
 
 Bonus: Write a function that takes n arrays as input and returns a single array that alternates the elements of each input array.
 */

let farr1 = [1,3,4,23,4,224,2,32,322,34,2,34,1,24,1,4,12,41,24,1]
let farr2 = [2,4,6,8,10,12,14,16,18,20,22,24]

func alternate(arr1: [Int], arr2: [Int]) -> [Int] {
    var alternated: [Int] = []
    let length = arr1.count + arr2.count
    let shorter: [Int]
    let longer: [Int]

    if arr1.count < arr2.count {
        shorter = arr1
        longer = arr2
    } else {
        shorter = arr2
        longer = arr1
    }

    for index in 0..<length where index < shorter.count {
            alternated.append(shorter[index])
            alternated.append(longer[index])
    }

    if alternated.count < length {
        let newStartingIndex = shorter.count
        for index in newStartingIndex..<longer.count {
            alternated.append(longer[index])
        }
    }

    return alternated
}

let alt = alternate(arr1: arr1, arr2: arr2)
print(alt)


class Node2 {
    var key: String!
    var next: Node2?
}

var head = Node2()
head.key = "Apple"
head.next = Node2()
head.next?.key = "Orange"
head.next?.next = Node2()
head.next?.next?.key = "Banana"
head.next?.next?.next = Node2()
head.next?.next?.next?.key = "Carrot"
head.next?.next?.next?.next = Node2()
head.next?.next?.next?.next?.key = "Beet"

var only = Node2()
only.key = "dcfwf"

func listLength(startingAt head: Node2) -> Int {
    guard head.key != nil else { return 0 }
    
    var length = 1
    
    var current = head
    var nextUp = current.next
    
    while nextUp != nil {
        current = nextUp!
        nextUp = current.next
        length += 1
    }
    
    return length
}

listLength(startingAt: head)
listLength(startingAt: only)

func pairSums(_ arr: [Int], _ sum: Int) -> [[Int]] {
    var pairs: [[Int]] = []
    var addUpToSum: [Int: Int] = [:]
    
    for numBeingChecked in arr {
        let itsPair = sum - numBeingChecked

        if addUpToSum[itsPair] == numBeingChecked {
            let pairFound = [numBeingChecked, itsPair]
            pairs.append(pairFound)
        } else {
            addUpToSum[numBeingChecked] = itsPair
        }
    }
    
    return pairs
}

pairSums([1,1], 2)

/*
 swift trace
 */

func trace(take: String, andMakeThem: String, inThis: String) -> String {
    if take.isEmpty || andMakeThem.isEmpty || inThis.isEmpty {
        return "Empty strings? We need values in every parameter!"
    }
    
    let takeArr: [Character] = Array(take.characters)
    let makeThemArr: [Character] = Array(andMakeThem.characters)
    let check = takeArr.count
    
    guard makeThemArr.count == check else {
        return "How can we know what to swap for what if the number of characters in each is uneven??"
    }
    
    let iterateOver: [Character] = Array(inThis.characters)
    var newString = ""
    var swapChar: [Character: Character] = [:]
    
    for index in 0..<takeArr.count {
        swapChar[takeArr[index]] = makeThemArr[index]
    }
    
    for char in iterateOver {
        let addThis = swapChar[char] ?? char
        
        newString += String(addThis)
    }
    
    return newString
}

var printTrace = trace(take: "abc", andMakeThem: "ABC", inThis: "charles")
print(printTrace)

/*
 https://leetcode.com/problems/valid-parentheses/
 Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
 
 The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.
 */

func checkMy(braces: String) -> Bool {
    let bracesArr = Array(braces.characters)
    
    if bracesArr.count <= 1 { return false }
    
    var countParentheses = 0
    var countCurlyBraces = 0
    var countSquareBraces = 0
    
    for index in 0..<bracesArr.count {
        guard bracesArr.count >= index + 1 else { return false }
        
        switch bracesArr[index] {
        case "(":
            countParentheses += 1
            
            if bracesArr[index + 1] == ")" { continue }
            else {
                if !bracesArr[index..<bracesArr.count].contains(")") { return false }
            }
            
        case "[":
            countSquareBraces += 1
            
            if bracesArr[index + 1] == "]" { continue }
            else {
                if !bracesArr[index..<bracesArr.count].contains("]") { return false }
            }
            
        case "{":
            countCurlyBraces += 1
            
            if bracesArr[index + 1] == "}" { continue }
            else {
                if !bracesArr[index..<bracesArr.count].contains("}") { return false }
            }
            
        case ")":
            countParentheses += 1
            
            if bracesArr[index - 1] == "(" { continue }
            else {
                if countParentheses % 2 != 0 || !bracesArr[0..<index].contains("(") { return false }
            }
            
        case "]":
            countSquareBraces += 1
            
            if bracesArr[index - 1] == "[" { continue }
            else {
                if countParentheses % 2 != 0 || !bracesArr[0..<index].contains("[") { return false }
            }
            
        case "}":
            countCurlyBraces += 1
            
            if bracesArr[index - 1] == "{" { continue }
            else {
                if countParentheses % 2 != 0 || !bracesArr[0..<index].contains("{") { return false }
            }
            
        default:
            continue
        }
    }
    
    return true
}

checkMy(braces: "([({)])")

public class ListNode {
      public var val: Int
      public var next: ListNode?
      public init(_ val: Int) {
          self.val = val
          self.next = nil
      }
}

func isPalindrome(_ head: ListNode?) -> Bool {
    var checker: [Int] = []
    var current = head
    guard head?.next != nil else { return true }
    var nextUp = current?.next
    
    while current != nil {
        checker.append(current!.val)
        current = nextUp
        nextUp = current?.next
    }
    
    for index in 0..<checker.count where index <= checker.count/2 {
        if checker[index] != checker[checker.count - 1 - index] { return false }
    }
    
    return true
}

// slower but somewhat more readable

func reverseVowels(_ s: String) -> String {
    let vowelsToFind = Array("aeiouAEIOU".characters)
    let sArr = Array(s.characters)
    var holdVowels = [Character]()
    var finalString = ""
    
    for char in sArr where vowelsToFind.contains(char) {
        holdVowels.append(char)
    }
    
    for char in sArr {
        if vowelsToFind.contains(char) {
            finalString += String(describing: holdVowels.popLast()!)
        } else {
            finalString += String(char)
        }
    }
    
    return finalString
}

// faster

func reverseVowels(_ s: String) -> String {
    let sArr = Array(s.characters)
    let vowelsToFind = Array("aeiouAEIOU".characters)
    var vowelsWeFound = [Character]()
    var foundVowelIndexSwapper = 0
    var finalString = ""
    
    for char in sArr where vowelsToFind.contains(char) {
        vowelsWeFound.append(char)
    }
    
    vowelsWeFound = vowelsWeFound.reversed()
    
    for char in sArr {
        if vowelsToFind.contains(char) {
            finalString += String(describing: vowelsWeFound[foundVowelIndexSwapper])
            foundVowelIndexSwapper += 1
        } else {
            finalString += String(char)
        }
    }
    
    return finalString
}

// Plus/minus problem from hackerRank

let n = Int(readLine()!)!

// read array and map the elements to integer
let arr = readLine()!.components(separatedBy: " ").map{ Int($0)! }

func plusMinus(_ n: Int, _ arr: [Int]) {
    var neg = 0.0
    var pos = 0.0
    var zero = 0.0
    
    for item in arr {
        if item > 0 {
            pos += 1.0
        } else if item < 0 {
            neg += 1.0
        } else {
            zero += 1.0
        }
    }
    
    print(pos/Double(n))
    print(neg/Double(n))
    print(zero/Double(n))
}

plusMinus(n, arr)

func findPowersOf2(_ arr: [Int]) -> [Int]? {
    func helper(_ num: Int) -> Bool {
        guard num != 2 else { return true }
        
        let divisor = num/2
        
        if divisor % 2 == 0 {
           return helper(divisor)
        }
        
        return false
    }
    
    var foundPowers: [Int] = []
    
    guard !arr.isEmpty else { return nil }
    
    for num in arr where num % 2 == 0 {
        if helper(num) {
            foundPowers.append(num)
        }
    }
    
    return foundPowers
}

func factorial(_ num: Int) -> Int {
    var product = 1
    for index in 1...num {
        product *= index
    }
    return product
}

func recursiveFactorial(_ num: Int, _ iterator: Int = 1, _ product: Int = 1) -> Int {
    guard iterator <= num else { return product }
    let currentProduct = iterator * product
    let newIterator = iterator + 1
    return recursiveFactorial(num, newIterator, currentProduct)
}

func recursivelyCountTheLetter(_ letter: String, in string: String) -> Int {
    guard !string.isEmpty else { return 0 }
    
    if letter == String(string[string.startIndex]) {
        return recursivelyCountTheLetter(letter, in: string.substring(from: string.index(after: string.startIndex))) + 1
    }
    
    return recursivelyCountTheLetter(letter, in: string.substring(from: string.index(after: string.startIndex)))
}

func nthDigit(_ n: Int) -> Int {
    var string = ""
    
    for num in 1...n {
        string.append(String(num))
    }
    
    let stringArr: [Character] = Array(string.characters)
    return Int(String(stringArr[n - 1]))!
}

var primes: [Int] = []

func findPrimesRecursively(_ n: Int, listMaker: Int = 2) -> Bool {
    guard n > 1 || n % 2 != 0 else { return false }
    guard listMaker <= Int(sqrt(Double(n))) else { return true }
    
    primes.append(listMaker)
    
    for number in primes {
        if n % number == 0 {
            return false
        } else {
            if !primes.contains(number) {
                primes.append(number)
            }
        }
    }
    return findPrimesRecursively(n, listMaker: listMaker + 1)
}

/*
//: Playground - noun: a place where people can play

import UIKit
import AVKit
import AVFoundation

var str = "Hello, playground"

print("Hello World!")

class Node {
    let val: UInt
    
    var left: Node?
    var right: Node?
    var previous: Node?
    
    init(_ val: UInt) {
        self.val = val
    }
    
    func showPrevious() -> UInt? {
        return self.previous?.val
    }
}

extension Node {
    func takeOneStep() {
        if self.weCanStepThisFar(1) {
            self.left = Node(1)
            self.left?.previous = self
        } else {
            print("We can't step any further")
            return
        }
    }
    
    func takeTwoSteps() {
        if self.weCanStepThisFar(2) {
            self.right = Node(2)
            self.right?.previous = self
        } else {
            print("We can't step two at a time right now.")
            return
        }
    }
    
    func weCanStepThisFar(_ step: UInt) -> Bool {
        if let unwrapCountdown = self.countDown() {
            print(unwrapCountdown >= step)
            return unwrapCountdown >= step
        } else {
            // if countDown is nil, we're in the root node
            return self.val >= step
        }
    }
    
    func countDown() -> UInt? {
        if let unwrapPrevious = self.previous?.val {
            print(unwrapPrevious - self.val)
            return unwrapPrevious - self.val
        } else {
            return nil
        }
    }
}

class binaryTree {
    var root: Node
    
    init(_ root: Node) {
        self.root = root
    }
    
    func countChildren() -> Int {
        var count = 0
        

        
        return count
    }
}

let firstNode = Node(4)

let tree = binaryTree(firstNode)
tree.root.takeOneStep()

print("")
tree.root.left?.countDown()
tree.root.left?.takeTwoSteps()
tree.root.left?.countDown()
*/

func maxSubArray(_ nums: [Int]) -> Int {
    var sum = Int.min
    
    if nums.count == 1 { return nums[0] }
    if nums.isEmpty { return 0 }
    
    for indexOfFirstNum in 0..<nums.count {
        var internalSum = nums[indexOfFirstNum]
        
        guard (indexOfFirstNum + 1) != nums.count else { break }
        
        for indexOfSecondNum in (indexOfFirstNum + 1)..<nums.count {
            internalSum += nums[indexOfSecondNum]
            if internalSum >= sum {
                sum = internalSum
            } else if internalSum < sum {
                break
            }
        }
    }
    
    return sum
}

func checkEvenOdd(_ arr: [Int]) -> [Int] {
    var evens = 0
    var odds = 0
    var divisibleBy3 = 0
    
    for num in arr {
        if num % 2 == 0 {
            evens += 1
        } else {
            odds += 1
            
            if num % 3 == 0 {
                divisibleBy3 += 1
            }
        }
    }
    
    let finalArr = [evens, odds, divisibleBy3]
    
    return finalArr
}


func findUniques(_ arr: [Int]) -> [Int] {
    guard arr.count != 0 else {
        print("The array is empty")
        return []
    }

    var uniques = [Int]()
    let checkForDupes = Set(arr)
    var runningTally = [Int : Int]()

    for item in checkForDupes {
        runningTally[item] = 0
    }

    for item in arr {
        runningTally[item]! += 1
    }

    for (key,val) in runningTally where val == 1 {
        uniques.append(key)
    }

    return uniques
}

for num in 1...5 {
    oneToFive.append(num)
}

var oneUpToButNotIncludingSix = [Int]()

for num in 1..<6 {
    oneUpToButNotIncludingSix.append(num)
}

print(oneUpToButNotIncludingSix == oneToFive)

let residents = ["Lisa" : "Springfield",
                 "Leela" : "New New York",
                 "Batman": "Gotham City",
                 "Faramir": "Osgiliath",
                 "Daenerys" : "Meereen"]
let strongWomen = ["Lisa", "Leela", "Daenerys"]
let fantasyTowns = ["Osgiliath", "Meereen"]

residents.filter{fantasyTowns.contains($0.value)}.map{print($0.0)}

findUniques([1,1,1,1,1,1,1,4,0])

func countTheLetters(_ text: String) -> [Character : Int]? {
    guard !text.isEmpty else {
        print("You gave me an empty string")
        return nil
    }

    var runningTally = [Character : Int]()
    let chars = Array(text.characters)
    let recordTheDifferentLetters = Set(chars)

    recordTheDifferentLetters.map { runningTally[$0] = 0 }
    chars.map { runningTally[$0]! += 1 }

    return runningTally
}

countTheLetters("elephant")

func threeShortestWords(_ arr: [String]) -> [String]? {
    guard arr.count > 2 else {
        print("How can we find the 3 shortest words in an array that's smaller than 3??")
        return nil
    }

    var shortestOfAll: (word: String, length: Int) = ("", Int.max)
    var secondShortest: (word: String, length: Int) = ("", Int.max)
    var thirdShortest: (word: String, length: Int) = ("", Int.max)

    var topShortest = [String]()
    var runningTally = [String : Int]()

    for word in arr {
        runningTally[word] = word.characters.count
    }

    for item in runningTally {
        if item.value < shortestOfAll.length {
            thirdShortest = secondShortest
            secondShortest = shortestOfAll
            shortestOfAll.word = item.key
            shortestOfAll.length = item.value
        } else if item.value < secondShortest.length {
            thirdShortest = secondShortest
            secondShortest.word = item.key
            secondShortest.length = item.value
        } else if item.value < thirdShortest.length {
            thirdShortest.word = item.key
            thirdShortest.length = item.value
        }
    }

    _ = [
        shortestOfAll,
        secondShortest,
        thirdShortest
        ].map { topShortest.append($0.word) }

    return topShortest
}

threeShortestWords(["testing", "also"])

class LLNode {
    var key: Int
    var next: LLNode?
    
    init(key: Int) {
        self.key = key
    }
    
    func add(_ new: Int) {
        var keepGoing = self
        
        while keepGoing.next != nil {
            keepGoing = keepGoing.next!
        }
        
        keepGoing.next = LLNode(key: new)
    }
    
    func printKeys() {
        var keepGoing = self
        
        print(keepGoing.key)
        
        while keepGoing != nil {
            print(keepGoing.key)
            if let somethingNext = keepGoing.next {
                keepGoing = somethingNext
            } else {
                break
            }
        }
    }
}

let list = LLNode(key: 5)
list.add(14)
list.add(17)
list.add(23)

list.printKeys()

func searchLinkedList(head: LLNode, findMe: Int) -> Bool {
    var keepGoing = head
    
    while keepGoing != nil {
        if keepGoing.key == findMe {
            return true
        } else {
            if let somethingNext = keepGoing.next {
                keepGoing = somethingNext
            } else {
                break
            }
        }
    }
    
    return false
}

searchLinkedList(head: list, findMe: 5)

func recursiveZip(zig: [Int], zag: [Int], takeFromZig: Bool = true, finalArr: [Int] = []) -> [Int] {
    if zig.isEmpty && !zag.isEmpty {
        return finalArr + zag
    }
    
    if !zig.isEmpty && zag.isEmpty {
        return finalArr + zig
    }
    
    guard !zig.isEmpty && !zag.isEmpty else {
        return finalArr
    }
    
    var newArr = finalArr
    var newZig = zig
    var newZag = zag
    
    if takeFromZig {
        newArr.append(newZig.removeFirst())
    } else {
        newArr.append(newZag.removeFirst())
    }
    
    return recursiveZip(zig: newZig, zag: newZag, takeFromZig: !takeFromZig, finalArr: newArr)
}

recursiveZip(zig: [100,500,1000], zag: [6,7,8,9,10])

class Node<T> {
    var key: T?
    var next: Node<T>?
}

class LinkedList<T> {
    var head: Node<T>
    var tail: Node<T>
    init() {
        self.head = Node<T>()
        self.tail = head
    }
}
class Queue<T> {
    private var list = LinkedList<T>()
    func enQueue(newElement: T) {
        if list.head.key == nil {
            list.head.key = newElement
            return
        } else {
            let newNode = Node<T>()
            newNode.key = newElement
            list.tail.next = newNode
            list.tail = newNode
        }
    }
    
    func deQueue() -> T? {
        if let oldHeadKey = list.head.key {
            if let nextNode = list.head.next {
                list.head = nextNode
            } else {
                list.head.key = nil
            }
            return oldHeadKey
        } else {
            return nil
        }
    }
    
    func isEmpty() -> Bool {
        return list.head.key == nil
    }
    
    func peek() -> T? {
        return list.head.key
    }
}

func skipTheLine(queue: Queue<Any>, value: Any) -> Queue<Any> {
    var cutLine = Queue<Any>()
    
    if cutLine.isEmpty() {
        cutLine.enQueue(newElement: value)
    } else {
        while queue.peek != nil {
            cutLine.enQueue(newElement: queue.deQueue()!)
        }
    }
    
    return cutLine
}

var first = Queue<Any>()
first.enQueue(newElement: 9)
first.enQueue(newElement: 4)
first.enQueue(newElement: 10)
first.enQueue(newElement: 3)
first.enQueue(newElement: 2)
let second = skipTheLine(queue: first, value: 14)
second.peek()
first.peek()

func skipTheLineAlt(queue: Queue<Any>, value: Any) -> Queue<Any> {
    var holdThese = [Any]()
    holdThese.append(value)
        
    while !queue.isEmpty() {
        holdThese.append(queue.deQueue())
    }
    
    while !holdThese.isEmpty {
        queue.enQueue(newElement: holdThese.removeFirst())
    }
    
    return queue
}

let third = skipTheLineAlt(queue: first, value: 12)
third.peek()
first.peek()

func reverseStringRedux(_ text: String) -> String {
    var finalString: String = ""
    
    guard !palindromeRedux(text) else {
        return text
    }
    
    let textArr = Array(text.characters)
    print(textArr)
    
    for index in 0...textArr.count - 1 {
        finalString += String(textArr[textArr.count - 1 - index])
    }
    
    return finalString
}

func palindromeRedux(_ text: String) -> Bool {
    let textArr = Array(text.characters)
    var modifier: Int = 0
    
    if textArr.count % 2 != 0 {
        modifier = 1
        for index in 0...((textArr.count/2) + modifier) {
            if textArr[index] != textArr[textArr.count - 1 - index] {
                return false
            }
        }
    }
    
    return true
}

func pushZeros(testCases: Int, arrCount: Int, nums: [Int]) -> [Int] {
    var returnArr = nums
    
    for num in nums {
        if num == 0 {
            returnArr.append(0)
        }
    }
    
    for num in nums {
        if num == 0 {
            returnArr.remove(at: returnArr.index(of: num)!)
        }
    }
    
    return returnArr
}

pushZeros(testCases: 1, arrCount: 5, nums: [3,5,0,0,4])

let numOfCandles = Int(readLine()!)!
let heightOfCandles = readLine()!.components(separatedBy: " ").map{ Int($0)! }
let tallestCandleValue = heightOfCandles.max()
var numberOfTallestCandles = 0

for index in 0..<numOfCandles where heightOfCandles[index] == tallestCandleValue {
    numberOfTallestCandles += 1
}

print(numberOfTallestCandles)

let arr = readLine()!.components(separatedBy: " ").map { Int($0) }

var arrayOfSums = [Int]()

for index in 0..<arr.count {
    var sum = 0
    
    for jindex in 0..<arr.count where jindex != index {
        sum += arr[jindex]!
    }
    
    arrayOfSums.append(sum)
}

print(arrayOfSums.min()!, arrayOfSums.max()!)

